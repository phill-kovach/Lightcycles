<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Paranoids Labyrinth</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        body {
            background-color: #000;
            color: #00ffff;
            font-family: 'Orbitron', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            text-align: center;
            padding: 1vmin;
            box-sizing: border-box;
        }

        #main-game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Changed to flex-start for tighter spacing */
            width: 100%;
            max-width: 650px;
            height: 100%;
            gap: 20px; /* Added a gap for consistent spacing */
        }

        /* Game Container */
        #game-container {
            position: relative;
            width: 95vmin;
            height: 95vmin;
            max-width: 600px;
            max-height: 600px;
            background: #000;
            border: 2px solid #00ffff;
            box-shadow: 0 0 20px #00ffff, 0 0 10px #00ffff inset;
            border-radius: 10px;
            overflow: hidden;
            transition: box-shadow 0.5s ease-in-out, border-color 0.5s ease-in-out;
            margin-bottom: 0; /* Adjusted margin */
        }

        #game-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Info Panel */
        #info-panel-container {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1vmin 0;
            margin-bottom: 0; /* Adjusted margin */
        }
        .info-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 2vmin;
            font-size: 2.5vmin; /* Adjusted font size */
            text-shadow: 0 0 5px #00ffff;
            justify-content: center;
            margin-bottom: 0; /* Adjusted margin */
        }
        #health-bar-container {
            width: 15vmin; /* Adjusted width */
            height: 2vmin; /* Adjusted height */
            border: 2px solid #00ff00;
            border-radius: 5px;
            box-shadow: 0 0 5px #00ff00;
            margin-left: 2vmin;
        }
        #health-bar {
            height: 100%;
            background-color: #00ff00;
            transition: width 0.3s ease-in-out;
        }

        /* Controls */
        #controls-container {
            padding: 2vmin;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2vmin;
        }
        #gameboy-controls {
            display: flex;
            align-items: center;
            justify-content: space-around;
            width: 100%;
            max-width: 800px;
            transform: scale(1.0); /* Adjusted default scale */
            transition: transform 0.2s ease-in-out;
        }
        .d-pad {
            display: grid;
            grid-template-areas:
                ". up ."
                "left . right"
                ". down .";
            width: 15vmin;
            height: 15vmin;
            background: #222;
            border-radius: 10px;
            box-shadow: 0 0 10px #00ffff;
            padding: 1vmin;
            position: relative;
        }
        .d-pad-button {
            background-color: #555;
            color: #00ffff;
            border: 2px solid #00ffff;
            border-radius: 5px;
            font-size: 2.5vmin; /* Adjusted font size */
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 0 5px #00ffff;
        }
        .d-pad-button:active {
            background-color: #00ffff;
            color: #000;
            box-shadow: 0 0 10px #00ffff;
            transform: scale(0.95);
        }
        .d-pad .up { grid-area: up; }
        .d-pad .down { grid-area: down; }
        .d-pad .left { grid-area: left; }
        .d-pad .right { grid-area: right; }

        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 2vmin; /* Adjusted gap */
            margin-left: 2vmin; /* Adjusted margin */
        }
        .action-button {
            width: 8vmin; /* Adjusted width */
            height: 8vmin; /* Adjusted height */
            border-radius: 50%;
            background-color: #ff00ff;
            color: #000;
            border: 2px solid #ff00ff;
            box-shadow: 0 0 10px #ff00ff;
            font-size: 2.5vmin; /* Adjusted font size */
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        .action-button:active {
            background-color: #00ffff;
            color: #000;
            box-shadow: 0 0 10px #00ffff;
            transform: scale(0.95);
        }

        .menu-option {
            padding: 1.5vmin 3vmin; /* Adjusted padding */
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5vmin; /* Adjusted font size */
            color: #000;
            background-color: #00ffff;
            border: 2px solid #00ffff;
            border-radius: 8px;
            cursor: pointer;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            box-shadow: 0 0 10px #00ffff;
            transition: all 0.3s ease;
        }
        .menu-option:hover {
            transform: scale(1.05);
            background-color: #33ffff;
            box-shadow: 0 0 20px #00ffff;
        }
        .menu-option:active {
            transform: scale(1);
            box-shadow: 0 0 5px #00ffff;
        }
        .button-group {
            display: flex;
            gap: 2vmin;
            justify-content: center;
            margin-top: 1vmin;
        }

        /* Pause Menu and Message Box */
        #pause-menu, #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #00ffff;
            padding: 3vmin;
            border-radius: 15px;
            box-shadow: 0 0 25px #00ffff;
            display: none;
            z-index: 200;
            flex-direction: column;
            gap: 2vmin;
            min-width: 30vmin;
        }
        #pause-menu h2, #message-box h2 {
            margin: 0;
            color: #00ffff;
            text-shadow: 0 0 5px #00ffff;
            font-size: 4vmin; /* Adjusted font size */
        }
        .control-sliders {
            display: flex;
            flex-direction: column;
            gap: 2vmin;
        }
        .slider-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            color: #00ffff;
        }
        .slider-group label {
            font-size: 2vmin; /* Adjusted font size */
            margin-bottom: 1vmin;
        }
        .slider-group input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            height: 1vmin;
            background: #555;
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 2.5vmin;
            height: 2.5vmin;
            background: #00ffff;
            border: 2px solid #000;
            border-radius: 50%;
            cursor: pointer;
        }
        .slider-group input[type="range"]::-moz-range-thumb {
            width: 2.5vmin;
            height: 2.5vmin;
            background: #00ffff;
            border: 2px solid #000;
            border-radius: 50%;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="main-game-container">
        <!-- Game Area -->
        <div id="game-container">
            <canvas id="game-canvas"></canvas>
            <!-- Pause Menu and Message Box are children of game-container to be positioned over it -->
            <div id="pause-menu" style="display: none;">
                <h2>Pause</h2>
                <button id="resume-button" class="menu-option">Resume Game</button>
                <button id="new-game-button" class="menu-option">New Game</button>
                <div class="control-sliders">
                    <div class="slider-group">
                        <label for="control-size-slider">Control Size:</label>
                        <input type="range" id="control-size-slider" min="50" max="150" value="100">
                    </div>
                </div>
            </div>
            <div id="message-box">
                <h2 id="message-title">Game Over</h2>
                <p id="message-text">Your final score is: <span id="final-score">0</span></p>
                <button id="box-restart-button" class="menu-option">Play Again</button>
            </div>
        </div>

        <!-- Info Panel -->
        <div id="info-panel-container">
            <div class="info-panel">
                <p>Score: <span id="score-display">0</span></p>
                <p>Enemies Left: <span id="enemies-display">3</span></p>
                <p>Health: <div id="health-bar-container"><div id="health-bar"></div></div></p>
            </div>
        </div>

        <!-- Controls Area -->
        <div id="controls-container">
             <div class="button-group">
                <button id="start-pause-button" class="menu-option">Start Game</button>
            </div>
            <div id="gameboy-controls">
                <!-- D-Pad -->
                <div class="d-pad">
                    <button class="d-pad-button up" data-direction="up">▲</button>
                    <button class="d-pad-button down" data-direction="down">▼</button>
                    <button class="d-pad-button left" data-direction="left">◄</button>
                    <button class="d-pad-button right" data-direction="right">►</button>
                </div>
                <!-- Action Buttons -->
                <div class="action-buttons">
                    <button class="action-button" id="fire-button">A</button>
                    <button class="action-button" id="aim-button">B</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score-display');
        const enemiesDisplay = document.getElementById('enemies-display');
        const startPauseButton = document.getElementById('start-pause-button');
        const resumeButton = document.getElementById('resume-button');
        const newGameButton = document.getElementById('new-game-button');
        const messageBox = document.getElementById('message-box');
        const finalScoreDisplay = document.getElementById('final-score');
        const boxRestartButton = document.getElementById('box-restart-button');
        const healthBar = document.getElementById('health-bar');
        const gameContainer = document.getElementById('game-container');
        const pauseMenu = document.getElementById('pause-menu');
        const dPad = document.querySelector('.d-pad');
        const fireButton = document.getElementById('fire-button');
        const aimButton = document.getElementById('aim-button');
        const controlSizeSlider = document.getElementById('control-size-slider');
        const gameboyControlsContainer = document.getElementById('gameboy-controls');

        let isGameOver = true;
        let isPaused = false;
        let score = 0;
        let animationFrameId;
        let explosions = [];
        let powerUps = [];
        let lastPowerUpSpawn = 0;
        let isTransitioningLevel = false;
        let levelTimeoutId = null;
        let playerDefaultColor = '#00ffff';
        let playerIsFlashing = false;
        let defaultBorderColor = '#00ffff';
        let defaultBorderShadow = '0 0 20px #00ffff, 0 0 10px #00ffff inset';

        // Maze dimensions
        const MAZE_WIDTH = 13;
        const MAZE_HEIGHT = 13;
        let CELL_SIZE = 40;
        let maze = [];

        function generateMaze() {
            maze = Array(MAZE_HEIGHT).fill(null).map(() => Array(MAZE_WIDTH).fill(1));
            const stack = [];
            const startX = Math.floor(Math.random() * MAZE_WIDTH);
            const startY = Math.floor(Math.random() * MAZE_HEIGHT);
            stack.push({ x: startX, y: startY });
            maze[startY][startX] = 0;
            const directions = [{x: 0, y: 1}, {x: 0, y: -1}, {x: 1, y: 0}, {x: -1, y: 0}];
            while(stack.length > 0) {
                const current = stack[stack.length - 1];
                const neighbors = [];
                directions.forEach(dir => {
                    const nextX = current.x + dir.x * 2;
                    const nextY = current.y + dir.y * 2;
                    if (nextX >= 0 && nextX < MAZE_WIDTH && nextY >= 0 && nextY < MAZE_HEIGHT && maze[nextY][nextX] === 1) {
                        neighbors.push({ x: nextX, y: nextY, dir: dir });
                    }
                });
                if (neighbors.length > 0) {
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    maze[current.y + next.dir.y][current.x + next.dir.x] = 0;
                    maze[next.y][next.x] = 0;
                    stack.push({ x: next.x, y: next.y });
                } else {
                    stack.pop();
                }
            }
        }

        function drawMaze() {
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 2;
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 10;
            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    if (maze[y][x] === 1) {
                        ctx.beginPath();
                        ctx.rect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        ctx.stroke();
                    }
                }
            }
            ctx.shadowBlur = 0;
        }

        // Player (Tank)
        const player = {
            x: 0,
            y: 0,
            size: 20,
            baseSpeed: 1.5,
            currentSpeed: 1.5,
            baseFireRate: 300,
            currentFireRate: 300,
            health: 100,
            maxHealth: 100,
            color: playerDefaultColor,
            velocity: { x: 0, y: 0 },
            turretAngle: -Math.PI / 2,
            draw: function() {
                ctx.fillStyle = this.color;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.rect(this.x, this.y, this.size, this.size);
                ctx.fill();
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(this.x + this.size / 2, this.y + this.size / 2);
                const turretLength = this.size * 1.0;
                const turretX = this.x + this.size / 2 + turretLength * Math.cos(this.turretAngle);
                const turretY = this.y + this.size / 2 + turretLength * Math.sin(this.turretAngle);
                ctx.lineTo(turretX, turretY);
                ctx.lineWidth = 4;
                ctx.stroke();
                ctx.shadowBlur = 0;
            },
            update: function() {
                const newX = this.x + this.velocity.x;
                const newY = this.y + this.velocity.y;
                
                // Check collision for X axis first
                if (!checkWallCollision(newX, this.y, this.size)) {
                    this.x = newX;
                }
                
                // Then check collision for Y axis
                if (!checkWallCollision(this.x, newY, this.size)) {
                    this.y = newY;
                }
            }
        };

        function updateHealthBar() {
            const healthPercentage = (player.health / player.maxHealth) * 100;
            healthBar.style.width = `${healthPercentage}%`;
            healthBar.style.backgroundColor = healthPercentage > 50 ? '#00ff00' : (healthPercentage > 25 ? '#ffff00' : '#ff0000');
            healthBar.style.boxShadow = `0 0 5px ${healthBar.style.backgroundColor}`;
        }

        class Projectile {
            constructor(x, y, vx, vy, color, target = 'enemy') {
                this.x = x;
                this.y = y;
                this.size = 5;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.target = target;
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
            }
        }

        let projectiles = [];
        let enemyProjectiles = [];
        let powerUpSpawnTimer = 0;
        let powerUpSpawnInterval = 5000;
        class PowerUp {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.size = 15;
                this.type = type;
                this.color = '';
                this.duration = 5000;
                if (type === 'health') this.color = '#00ff00';
                if (type === 'speed') this.color = '#ffff00';
                if (type === 'fireRate') this.color = '#ff00ff';
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(this.x + this.size / 2, this.y + this.size / 2, this.size / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        function spawnPowerUp() {
            const powerUpTypes = ['health', 'speed', 'fireRate'];
            const type = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
            let placed = false;
            let attempts = 0;
            while(!placed && attempts < 100) {
                const x = Math.floor(Math.random() * MAZE_WIDTH);
                const y = Math.floor(Math.random() * MAZE_HEIGHT);
                if (maze[y][x] === 0) {
                    const powerUp = new PowerUp(
                        x * CELL_SIZE + (CELL_SIZE - 15) / 2,
                        y * CELL_SIZE + (CELL_SIZE - 15) / 2,
                        type
                    );
                    powerUps.push(powerUp);
                    placed = true;
                }
                attempts++;
            }
        }

        class Enemy {
            constructor() {
                this.size = 20;
                this.x = 0;
                this.y = 0;
                this.speed = 1;
                this.color = '#ff9900';
                this.lastShot = Date.now();
                this.fireRate = 2000;
                const directions = [{vx: 1, vy: 0}, {vx: -1, vy: 0}, {vx: 0, vy: 1}, {vx: 0, vy: -1}];
                const randomDirection = directions[Math.floor(Math.random() * directions.length)];
                this.vx = randomDirection.vx * this.speed;
                this.vy = randomDirection.vy * this.speed;
            }
            draw() {
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.rect(this.x, this.y, this.size, this.size);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(this.x + this.size / 2, this.y + this.size / 2);
                ctx.lineTo(this.x + this.size / 2, this.y + this.size);
                ctx.lineWidth = 4;
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
            update() {
                const newX = this.x + this.vx;
                const newY = this.y + this.vy;
                
                // Check collision for X axis, if collision, reverse direction
                if (checkWallCollision(newX, this.y, this.size)) {
                    this.vx = -this.vx;
                    this.x += this.vx; // Move away from the wall
                } else {
                    this.x = newX;
                }

                // Check collision for Y axis, if collision, reverse direction
                if (checkWallCollision(this.x, newY, this.size)) {
                    this.vy = -this.vy;
                    this.y += this.vy; // Move away from the wall
                } else {
                    this.y = newY;
                }
            }
            shoot() {
                if (Date.now() - this.lastShot > this.fireRate) {
                    enemyProjectiles.push(new Projectile(
                        this.x + this.size / 2,
                        this.y + this.size / 2,
                        0,
                        3,
                        '#ff0000',
                        'player'
                    ));
                    this.lastShot = Date.now();
                }
            }
        }

        let enemies = [];

        class Explosion {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.particles = [];
                for (let i = 0; i < 10; i++) {
                    this.particles.push({
                        x: 0,
                        y: 0,
                        radius: Math.random() * 2 + 1,
                        velocity: {
                            x: (Math.random() - 0.5) * 5,
                            y: (Math.random() - 0.5) * 5
                        },
                        alpha: 1
                    });
                }
            }
            draw() {
                this.particles.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(this.x + p.x, this.y + p.y, p.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${parseInt(this.color.slice(1,3), 16)}, ${parseInt(this.color.slice(3,5), 16)}, ${parseInt(this.color.slice(5,7), 16)}, ${p.alpha})`;
                    ctx.fill();
                });
            }
            update() {
                this.particles.forEach(p => {
                    p.x += p.velocity.x;
                    p.y += p.velocity.y;
                    p.alpha -= 0.05;
                });
                return this.particles.every(p => p.alpha <= 0);
            }
        }
        function checkCollision(obj1, obj2) {
            const dx = obj1.x - obj2.x;
            const dy = obj1.y - obj2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < (obj1.size + obj2.size) / 2;
        }

        function checkWallCollision(x, y, size) {
            const playerGridX = Math.floor(x / CELL_SIZE);
            const playerGridY = Math.floor(y / CELL_SIZE);
            const playerGridX2 = Math.floor((x + size) / CELL_SIZE);
            const playerGridY2 = Math.floor((y + size) / CELL_SIZE);
            if (playerGridX < 0 || playerGridX >= MAZE_WIDTH ||
                playerGridY < 0 || playerGridY >= MAZE_HEIGHT ||
                playerGridX2 < 0 || playerGridX2 >= MAZE_WIDTH ||
                playerGridY2 < 0 || playerGridY2 >= MAZE_HEIGHT) {
                return true;
            }
            if (maze[playerGridY][playerGridX] === 1 ||
                maze[playerGridY][playerGridX2] === 1 ||
                maze[playerGridY2][playerGridX] === 1 ||
                maze[playerGridY2][playerGridX2] === 1) {
                return true;
            }
            return false;
        }

        function gameOver() {
            isGameOver = true;
            cancelAnimationFrame(animationFrameId);
            finalScoreDisplay.textContent = score;
            document.getElementById('message-title').textContent = 'Game Over';
            document.getElementById('message-text').style.display = 'block';
            boxRestartButton.style.display = 'block';
            messageBox.style.display = 'flex';
            startPauseButton.style.display = 'block';
            startPauseButton.textContent = 'Start Game';
        }

        function winLevel() {
            isTransitioningLevel = true;
            cancelAnimationFrame(animationFrameId);
            score += 75;
            scoreDisplay.textContent = score;
            document.getElementById('message-title').textContent = 'Level Complete!';
            document.getElementById('message-text').textContent = `Your current score is: ${score}`;
            boxRestartButton.style.display = 'none';
            messageBox.style.display = 'flex';
            levelTimeoutId = setTimeout(() => {
                startNewLevel();
            }, 2000);
        }

        let powerUpEffectTimeoutId = null;
        function applyPowerUpEffect(color, duration) {
            if (powerUpEffectTimeoutId) {
                clearTimeout(powerUpEffectTimeoutId);
            }
            gameContainer.style.boxShadow = `0 0 20px ${color}, 0 0 10px ${color} inset`;
            gameContainer.style.borderColor = color;
            powerUpEffectTimeoutId = setTimeout(() => {
                gameContainer.style.boxShadow = defaultBorderShadow;
                gameContainer.style.borderColor = defaultBorderColor;
            }, duration);
        }

        function flashPlayerRed() {
            if (playerIsFlashing) return;
            playerIsFlashing = true;
            player.color = '#ff0000';
            gameContainer.style.boxShadow = `0 0 20px #ff0000, 0 0 10px #ff0000 inset`;
            gameContainer.style.borderColor = '#ff0000';
            setTimeout(() => {
                player.color = playerDefaultColor;
                gameContainer.style.boxShadow = defaultBorderShadow;
                gameContainer.style.borderColor = defaultBorderColor;
                playerIsFlashing = false;
            }, 500);
        }

        function gameLoop() {
            if (isGameOver || isTransitioningLevel || isPaused) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawMaze();
            powerUpSpawnTimer++;
            if (powerUpSpawnTimer > 600) {
                spawnPowerUp();
                powerUpSpawnTimer = 0;
            }
            powerUps.forEach(p => p.draw());
            updatePlayerMovement();
            player.update();
            player.draw();
            enemies.forEach((enemy, enemyIndex) => {
                enemy.update();
                enemy.draw();
                enemy.shoot();
                projectiles.forEach((projectile, projIndex) => {
                    if (checkCollision(projectile, enemy)) {
                        explosions.push(new Explosion(enemy.x + enemy.size/2, enemy.y + enemy.size/2, enemy.color));
                        enemies.splice(enemyIndex, 1);
                        projectiles.splice(projIndex, 1);
                        score += 10;
                        scoreDisplay.textContent = score;
                        enemiesDisplay.textContent = enemies.length;
                    }
                });
            });

            powerUps.forEach((p, index) => {
                if (checkCollision(player, p)) {
                    applyPowerUpEffect(p.color, p.duration);
                    if (p.type === 'health') {
                        player.health = Math.min(player.health + 25, player.maxHealth);
                        updateHealthBar();
                    } else if (p.type === 'speed') {
                        player.currentSpeed = player.baseSpeed * 1.5;
                        setTimeout(() => player.currentSpeed = player.baseSpeed, p.duration);
                    } else if (p.type === 'fireRate') {
                        player.currentFireRate = player.baseFireRate * 0.5;
                        setTimeout(() => player.currentFireRate = player.baseFireRate, p.duration);
                    }
                    powerUps.splice(index, 1);
                }
            });

            projectiles.forEach((projectile, projIndex) => {
                projectile.update();
                projectile.draw();
                if (checkWallCollision(projectile.x, projectile.y, projectile.size) || projectile.y < -projectile.size || projectile.x < -projectile.size || projectile.x > canvas.width + projectile.size) {
                    projectiles.splice(projIndex, 1);
                }
            });

            enemyProjectiles.forEach((projectile, projIndex) => {
                projectile.update();
                projectile.draw();
                if (checkCollision(projectile, player)) {
                    explosions.push(new Explosion(projectile.x, projectile.y, projectile.color));
                    enemyProjectiles.splice(projIndex, 1);
                    player.health -= 25;
                    updateHealthBar();
                    flashPlayerRed();
                    if (player.health <= 0) {
                        gameOver();
                    }
                }
                if (checkWallCollision(projectile.x, projectile.y, projectile.size) || projectile.y > canvas.height + projectile.size) {
                    enemyProjectiles.splice(projIndex, 1);
                }
            });

            for (let i = explosions.length - 1; i >= 0; i--) {
                const explosion = explosions[i];
                explosion.draw();
                if (explosion.update()) {
                    explosions.splice(i, 1);
                }
            }

            if (enemies.length === 0) {
                winLevel();
            }
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        const keys = {};
        let isAiming = false;
        let isShooting = false;
        let lastPlayerShot = Date.now();
        const dpadDirections = {
            'up': 'ArrowUp',
            'down': 'ArrowDown',
            'left': 'ArrowLeft',
            'right': 'ArrowRight'
        };

        const touchState = {
            'up': false, 'down': false, 'left': false, 'right': false,
            'fire': false, 'aim': false
        };

        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === ' ' || e.key === 'p' || e.key === 'P') {
                togglePause();
            }
        });
        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        dPad.querySelectorAll('.d-pad-button').forEach(button => {
            const direction = button.dataset.direction;
            button.addEventListener('mousedown', () => touchState[direction] = true);
            button.addEventListener('mouseup', () => touchState[direction] = false);
            button.addEventListener('mouseleave', () => touchState[direction] = false);
            button.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchState[direction] = true;
            });
            button.addEventListener('touchend', (e) => {
                e.preventDefault();
                touchState[direction] = false;
            });
            button.addEventListener('touchcancel', () => touchState[direction] = false);
        });

        fireButton.addEventListener('mousedown', () => touchState['fire'] = true);
        fireButton.addEventListener('mouseup', () => touchState['fire'] = false);
        fireButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchState['fire'] = true;
        });
        fireButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            touchState['fire'] = false;
        });
        fireButton.addEventListener('touchcancel', () => touchState['fire'] = false);

        aimButton.addEventListener('mousedown', () => touchState['aim'] = true);
        aimButton.addEventListener('mouseup', () => touchState['aim'] = false);
        aimButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchState['aim'] = true;
        });
        aimButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            touchState['aim'] = false;
        });
        aimButton.addEventListener('touchcancel', () => touchState['aim'] = false);

        function updatePlayerMovement() {
            player.velocity.x = 0;
            player.velocity.y = 0;
            if (keys['ArrowUp'] || keys['w'] || touchState['up']) player.velocity.y = -player.currentSpeed;
            if (keys['ArrowDown'] || keys['s'] || touchState['down']) player.velocity.y = player.currentSpeed;
            if (keys['ArrowLeft'] || keys['a'] || touchState['left']) player.velocity.x = -player.currentSpeed;
            if (keys['ArrowRight'] || keys['d'] || touchState['right']) player.velocity.x = player.currentSpeed;

            isAiming = keys['b'] || touchState['aim'];
            if (isAiming) {
                if (keys['ArrowUp'] || keys['w'] || touchState['up']) player.turretAngle = -Math.PI / 2;
                if (keys['ArrowDown'] || keys['s'] || touchState['down']) player.turretAngle = Math.PI / 2;
                if (keys['ArrowLeft'] || keys['a'] || touchState['left']) player.turretAngle = Math.PI;
                if (keys['ArrowRight'] || keys['d'] || touchState['right']) player.turretAngle = 0;
            } else {
                if (player.velocity.x === 0 && player.velocity.y < 0) player.turretAngle = -Math.PI / 2;
                else if (player.velocity.x === 0 && player.velocity.y > 0) player.turretAngle = Math.PI / 2;
                else if (player.velocity.x < 0 && player.velocity.y === 0) player.turretAngle = Math.PI;
                else if (player.velocity.x > 0 && player.velocity.y === 0) player.turretAngle = 0;
            }

            isShooting = keys[' '] || touchState['fire'];
            if (isShooting && Date.now() - lastPlayerShot > player.currentFireRate) {
                const projectileSpeed = 7;
                projectiles.push(new Projectile(
                    player.x + player.size / 2,
                    player.y + player.size / 2,
                    projectileSpeed * Math.cos(player.turretAngle),
                    projectileSpeed * Math.sin(player.turretAngle),
                    '#00ffff'
                ));
                lastPlayerShot = Date.now();
            }
        }

        function resizeCanvas() {
            canvas.width = gameContainer.clientWidth;
            canvas.height = gameContainer.clientHeight;
            CELL_SIZE = Math.floor(Math.min(canvas.width / MAZE_WIDTH, canvas.height / MAZE_HEIGHT));
            player.size = CELL_SIZE * 0.4;
            let placed = false;
            for (let y = 0; y < MAZE_HEIGHT && !placed; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    if (maze[y][x] === 0) {
                        player.x = x * CELL_SIZE + (CELL_SIZE - player.size) / 2;
                        player.y = y * CELL_SIZE + (CELL_SIZE - player.size) / 2;
                        placed = true;
                        break;
                    }
                }
            }
        }

        window.addEventListener('resize', resizeCanvas);

        function spawnEnemies() {
            const numEnemies = Math.min(5, Math.floor(MAZE_WIDTH * MAZE_HEIGHT / 20));
            enemies = [];
            let placed = 0;
            while (placed < numEnemies) {
                const x = Math.floor(Math.random() * MAZE_WIDTH);
                const y = Math.floor(Math.random() * MAZE_HEIGHT);
                const enemy = new Enemy();
                enemy.x = x * CELL_SIZE + (CELL_SIZE - enemy.size) / 2;
                enemy.y = y * CELL_SIZE + (CELL_SIZE - enemy.size) / 2;
                const dx = enemy.x - player.x;
                const dy = enemy.y - player.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                if (maze[y][x] === 0 && distance > 200) {
                    enemies.push(enemy);
                    placed++;
                }
            }
            enemiesDisplay.textContent = enemies.length;
        }

        function togglePause() {
            isPaused = !isPaused;
            if (isPaused) {
                cancelAnimationFrame(animationFrameId);
                pauseMenu.style.display = 'flex';
                startPauseButton.textContent = 'Resume Game';
            } else {
                pauseMenu.style.display = 'none';
                startPauseButton.textContent = 'Pause Game';
                gameLoop();
            }
        }

        function startGame() {
            if (levelTimeoutId) {
                clearTimeout(levelTimeoutId);
                levelTimeoutId = null;
            }
            isGameOver = true; // Set to true initially to prevent game loop from starting prematurely
            isPaused = false;
            score = 0;
            isTransitioningLevel = false;
            projectiles = [];
            enemyProjectiles = [];
            explosions = [];
            powerUps = [];
            player.health = player.maxHealth;
            player.currentSpeed = player.baseSpeed;
            player.currentFireRate = player.baseFireRate;
            scoreDisplay.textContent = score;
            messageBox.style.display = 'none';
            pauseMenu.style.display = 'none';
            startPauseButton.textContent = 'Pause Game';
            updateHealthBar();
            generateMaze();
            resizeCanvas();
            spawnEnemies();
            spawnPowerUp();
            if (powerUpEffectTimeoutId) {
                clearTimeout(powerUpEffectTimeoutId);
            }
            gameContainer.style.boxShadow = defaultBorderShadow;
            gameContainer.style.borderColor = defaultBorderColor;
            isGameOver = false; // Now set to false to start game loop
            gameLoop();
        }

        function startNewLevel() {
            isTransitioningLevel = false;
            messageBox.style.display = 'none';
            projectiles = [];
            enemyProjectiles = [];
            explosions = [];
            powerUps = [];
            player.currentSpeed = player.baseSpeed;
            player.currentFireRate = player.baseFireRate;
            scoreDisplay.textContent = score;
            enemiesDisplay.textContent = enemies.length;
            updateHealthBar();
            if (powerUpEffectTimeoutId) {
                clearTimeout(powerUpEffectTimeoutId);
            }
            gameContainer.style.boxShadow = defaultBorderShadow;
            gameContainer.style.borderColor = defaultBorderColor;
            generateMaze();
            resizeCanvas();
            spawnEnemies();
            spawnPowerUp();
            gameLoop();
        }

        startPauseButton.addEventListener('click', () => {
            if (isGameOver) {
                startGame();
            } else {
                togglePause();
            }
        });
        resumeButton.addEventListener('click', togglePause);
        newGameButton.addEventListener('click', startGame);
        boxRestartButton.addEventListener('click', startGame);

        controlSizeSlider.addEventListener('input', (e) => {
            const size = e.target.value;
            gameboyControlsContainer.style.transform = `scale(${size / 100})`;
        });

        window.onload = function() {
            generateMaze();
            resizeCanvas();
            player.x = (canvas.width / 2) - (player.size / 2);
            player.y = canvas.height - 50;
            updateHealthBar();
            gameboyControlsContainer.style.transform = `scale(${controlSizeSlider.value / 100})`;
        };
    </script>
</body>
</html>

